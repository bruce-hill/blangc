def JSON{|Object({Str=>JSON})|List([JSON])|String(Str)|Number(Num)|Boolean(Bool)|Null|Invalid($JSON)|}
    def serialized(j:JSON)->Str
        if j is Object(table)
            return [`{,
                for entry in table
                    c for c in "$(entry.key.quoted()): $(bitcast entry.value.serialized() as Str)"
                between
                    c for c in ", "
                , `}]
        is List(list)
            return [`[,
                for item in list
                    c for c in item.serialized()
                between
                    c for c in ", "
                , `]]
        is String(s)
            return s.quoted()
        is Number(x); Boolean(x)
            return "$x"
        is Null
            return "null"
        is Invalid(js)
            fail "invalid JSON: $js"

extend $JSON
    def deserialize(js:$JSON)->JSON
        def match(js:&$JSON, pattern:$JSON; inline)->Bool
            if (*js).starts_with(pattern)
                *js = (*js)[(#pattern+1)..]
                return yes
            else
                return no

        def match_chars(js:&$JSON, chars:$JSON; inline)->$JSON
            rest := (*js).trimmed(chars, trim_right=no)
            defer *js = rest
            matched := (*js)[..(#js - #rest)]
            return matched

        def skip_spaces(js:&$JSON; inline)
            *js = (*js).trimmed($JSON" \n\r\t", trim_right=no)

        def match_str(js:&$JSON)->JSON
            unless match(js, $JSON("))
                return JSON.Invalid(*js)
            content := *js
            for i,c in *js
                if c == `"
                    *js = js[(i+1)..]
                    return JSON.String(bitcast content[..(i-1)] as Str)
            return JSON.Invalid(*js)

        def match_bool(js:&$JSON)->JSON
            if match(js, $JSON"true")
                return JSON.Boolean(yes)
            if match(js, $JSON"false")
                return JSON.Boolean(no)
            return JSON.Invalid(*js)

        def match_null(js:&$JSON)->JSON
            return (if match(js, $JSON"null") then JSON.Null else JSON.Invalid(*js))

        def match_obj(js:&$JSON)->JSON
            unless match(js, $JSON"{")
                return JSON.Invalid(*js)

            skip_spaces(js)
            obj := &{:Str=>JSON}
            repeat
                key := if match_str(js) is String(s) then s else stop
                skip_spaces(js)
                unless match(js, $JSON":")
                    return JSON.Invalid(*js)
                skip_spaces(js)
                value := match_json(js)
                obj[key] = value

            unless match(js, $JSON"}")
                return JSON.Invalid(*js)

            return JSON.Object(*obj)

        def match_list(js:&$JSON)->JSON
            unless match(js, $JSON"[")
                return JSON.Invalid(*js)

            skip_spaces(js)
            list := &[:JSON]
            repeat
                skip_spaces(js)
                if item := match_json(js) is Invalid(_)
                    stop
                else
                    list.insert(item)
                
                skip_spaces(js)
                stop unless match(js, $JSON",")

            skip_spaces(js)
            unless match(js, $JSON"]")
                return JSON.Invalid(*js)

            return JSON.List(*list)

        def match_num(js:&$JSON)->JSON
            if Num.parse(bitcast *js as Str) is success(n)
                *js = (*js)[(#js+1)..]
                return JSON.Number(n)
            is partial_success({value=n, remainder=remaining})
                *js = (bitcast remaining as $JSON)
                return JSON.Number(n)
            else
                return JSON.Invalid(*js)

        def match_json(js:&$JSON)->JSON
            if m:=match_num(js) is Number(_) then return m
            if m:=match_str(js) is String(_) then return m
            if m:=match_obj(js) is Object(_) then return m
            if m:=match_bool(js) is Boolean(_) then return m
            if m:=match_list(js) is List(_) then return m
            if m:=match_null(js) is Null then return m
            return JSON.Invalid(*js)

        skip_spaces(&js)
        obj := match_json(&js)
        skip_spaces(&js)
        if #js > 0
            return JSON.Invalid(js)
        return obj


// $JSON DSL
def s:Str as $JSON
    return bitcast s.quoted() as $JSON

def b:Bool as $JSON
    return (if b then $JSON"true" else $JSON"false")

def n:Num as $JSON
    return bitcast "$n" as $JSON

if IS_MAIN_PROGRAM
    >>> JSON.Object({"x"=> JSON.Boolean(yes), "y"=> JSON.Null, "z"=> JSON.List([JSON.Number(1.2), JSON.Number(3.4)])}).serialized()
    === "{\"x\": yes, \"y\": null, \"z\": [1.2, 3.4]}"
    >>> JSON.String(${"Quotes" and \\backslashes}).serialized()
    === "\"\\"Quotes\\" and \\backslashes\""
    >>> $JSON|{"x": true}|.deserialize()
    === JSON.Object({"x"=>JSON.Boolean(yes)})
    >>> $JSON|[1,2]|.deserialize()
    === JSON.List([JSON.Number(1), JSON.Number(2)])
    >>> x := JSON.Object({"x"=> JSON.String("hello")})
    >>> x.Object["x"].String
    === "hello"
