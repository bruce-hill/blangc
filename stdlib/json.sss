def Object{|Map({Str=>Object})|List([Object])|String(Str)|Number(Num)|Boolean(Bool)|Null|Invalid(JSON)|}
    def j:Object as JSON
        if j is Map(table)
            return JSON::[`{,
                for entry in table
                    c for c in JSON::"$(Object.String(entry.key)): $(entry.value)"
                between
                    c for c in ", "
                , `}]
        is List(list)
            return JSON::[`[,
                for item in list
                    c for c in item as JSON
                between
                    c for c in ", "
                , `]]
        is String(s)
            return bitcast s.quoted() as JSON
        is Number(x); Boolean(x)
            return JSON::"$x"
        is Null
            return JSON::"null"
        is Invalid(js)
            fail "invalid JSON: $js"

def JSON::Str
    def js:JSON as Str
        return bitcast js as Str

    def js:JSON as Object
        def match(js:&JSON, pattern:JSON; inline)->Bool
            if (*js).starts_with(pattern)
                *js = (*js)[(#pattern+1)..]
                return yes
            else
                return no

        def match_chars(js:&JSON, chars:JSON; inline)->JSON
            rest := (*js).trimmed(chars, trim_right=no)
            defer *js = rest
            matched := (*js)[..(#js - #rest)]
            return matched

        def skip_spaces(js:&JSON; inline)
            *js = (*js).trimmed(JSON::" \n\r\t", trim_right=no)

        def match_str(js:&JSON)->Object
            unless match(js, JSON::$("))
                return Object.Invalid(*js)
            content := *js
            for i,c in *js
                if c == `"
                    *js = js[(i+1)..]
                    return Object.String(bitcast content[..(i-1)] as Str)
            return Object.Invalid(*js)

        def match_bool(js:&JSON)->Object
            if match(js, JSON::"true")
                return Object.Boolean(yes)
            if match(js, JSON::"false")
                return Object.Boolean(no)
            return Object.Invalid(*js)

        def match_null(js:&JSON)->Object
            return (if match(js, JSON::"null") then Object.Null else Object.Invalid(*js))

        def match_obj(js:&JSON)->Object
            unless match(js, JSON::"{")
                return Object.Invalid(*js)

            obj := &{:Str=>Object}
            repeat
                skip_spaces(js)
                key := if match_str(js) is String(s) then s else stop
                skip_spaces(js)
                unless match(js, JSON::":")
                    return Object.Invalid(*js)
                skip_spaces(js)
                value := match_json(js)
                obj[key] = value
                skip_spaces(js)
                stop unless match(js, JSON::",")

            unless match(js, JSON::"}")
                return Object.Invalid(*js)

            return Object.Map(*obj)

        def match_list(js:&JSON)->Object
            unless match(js, JSON::"[")
                return Object.Invalid(*js)

            skip_spaces(js)
            list := &[:Object]
            repeat
                skip_spaces(js)
                if item := match_json(js) is Invalid(_)
                    stop
                else
                    list.insert(item)
                
                skip_spaces(js)
                stop unless match(js, JSON::",")

            skip_spaces(js)
            unless match(js, JSON::"]")
                return Object.Invalid(*js)

            return Object.List(*list)

        def match_num(js:&JSON)->Object
            if Num.parse(bitcast *js as Str) is success(n)
                *js = (*js)[(#js+1)..]
                return Object.Number(n)
            is partial_success({value=n, remainder=remaining})
                *js = (bitcast remaining as JSON)
                return Object.Number(n)
            else
                return Object.Invalid(*js)

        def match_json(js:&JSON)->Object
            if m:=match_num(js) is Number(_) then return m
            if m:=match_str(js) is String(_) then return m
            if m:=match_obj(js) is Map(_) then return m
            if m:=match_bool(js) is Boolean(_) then return m
            if m:=match_list(js) is List(_) then return m
            if m:=match_null(js) is Null then return m
            return Object.Invalid(*js)

        skip_spaces(&js)
        obj := match_json(&js)
        skip_spaces(&js)
        if #js > 0
            return Object.Invalid(js)
        return obj

    def s:Str as JSON
        return bitcast s.quoted() as JSON

    def b:Bool as JSON
        return (if b then JSON::"true" else JSON::"false")

    def n:Num as JSON
        return bitcast "$n" as JSON

if IS_MAIN_PROGRAM
    >>> Object.Map({"x"=> Object.Boolean(yes), "y"=> Object.Null, "z"=> Object.List([Object.Number(1.2), Object.Number(3.4)])}) as JSON
    === JSON::"{\"x\": true, \"y\": null, \"z\": [1.2, 3.4]}"
    >>> Object.String(${"Quotes" and \\backslashes}) as JSON
    === JSON::"\"\\"Quotes\\" and \\backslashes\""
    >>> JSON::$|{"x": true}| as Object
    === Object.Map({"x"=>Object.Boolean(yes)})
    >>> JSON::$|[1,2]| as Object
    === Object.List([Object.Number(1), Object.Number(2)])
    >>> x := Object.Map({"x"=> Object.String("hello")})
    >>> x.Map["x"].String
