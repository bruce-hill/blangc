// Filesystem reading and manipulating library.

time := use time.sss

struct FileInfo{
    device, rdevice, inode, mode, links, user, group:Int64
    size,block_size:Int64<bytes>
    block_count:Int64
    accessed, modified, moved:time.Timestamp
}

enum Result := Failure(Str) | Success

// Opaque value:
alias _CFile::Void

struct File{raw_c_file:?_CFile}
    func line(f:@File)->Str
        return extern get_line(f.raw_c_file or fail "File has already been closed"):Str

    func lines(f:@File)->[Str]
        return [f.line() while not f.ended()]

    func ended(f:@File)->Bool
        return extern feof(f.raw_c_file or fail "File has already been closed"):Int32 == 1

    func info(f:@File)->FileInfo
        file := f.raw_c_file or fail "File has already been closed"
        return extern sss_fstat(file):FileInfo

    read := extern sss_readfile:(f:@File,bytes=Int64.max)->Str

    func write(f:@File, text:Str)->Result
        file := f.raw_c_file or fail "File has already been closed"
        for char in text
            wrote := extern fputc(char, file):Int32
            if wrote != char as Int32
                return Failure(extern last_err():Str)
        return Success

    func flush(f:@File)
        extern fflush(f.raw_c_file or return)

    func rewind(f:@File)
        extern rewind(f.raw_c_file or return)

    func close(f:@File)
        file := f.raw_c_file or return
        extern fclose(file)
        f.raw_c_file = !_CFile

stdin := @File{extern stdin:@_CFile}
stdout := @File{extern stdout:@_CFile}
stderr := @File{extern stderr:@_CFile}

enum OpenResult := Failure(Str) | Success(@File)

enum FileMode := Read=0 | Write=1 | ReadWrite=2
open := extern sss_fopen:(path:Str,mode="r")->OpenResult
temporary := extern sss_tmpfile:()->@File

enum TempDirResult := Failure(Str) | Success(Str)

func temp_directory(template="/tmp/dir.XXXXXX")->TempDirResult
    path := [c for c in template]
    c_str := path.c_string()
    if extern mkdtemp(c_str):?CStringChar is !CStringChar
        return Failure(extern last_err():Str)

    return Success(c_str.as_string())

func move(path:Str, dest:Str)->Result
    if extern rename(path.c_string(), dest):CError is SUCCESS
        return Success
    else
        return Failure((extern last_err:()->Str)())

func remove(path:Str)->Result
    if extern unlink(path.c_string()):CError is SUCCESS
        return Success
    else
        return Failure((extern last_err:()->Str)())

func remove_dir(path:Str)->Result
    if extern rmdir(path.c_string()):CError is SUCCESS
        return Success
    else
        return Failure((extern last_err:()->Str)())

func spoof(text:Str)->@File
    f := extern sss_tmpfile():@File
    _ := f.write(text)
    f.rewind()
    return f

alias Glob::Str
    func expand(g:Glob)->[Str]
        struct glob_t{
            gl_pathc:Int64
            gl_pathv:?@CStringChar
            gl_offs:Int64
            gl_flags:Int32
        }
        enum GlobResult := SUCCESS=0 | NOSPACE=1 | ABORTED=2 | NOMATCH=3
        flags := 17410i32 // GLOB_MARK | GLOB_BRACE | GLOB_TILDE_CHECK
        globbuf := glob_t{}
        result := extern glob((bitcast g as Str).c_string(), flags, !Void, &globbuf):GlobResult
        defer extern globfree(&globbuf)
        if result is SUCCESS
            mem_addr := bitcast (globbuf.gl_pathv or return [:Str]) as Int
            paths := [
                for i in 1..globbuf.gl_pathc
                    (*(bitcast (mem_addr + (i-1)*8) as @@CStringChar)).as_string()
            ]
            return [for p in paths if not p.ends_with("/./") and not p.ends_with("/../") then p else skip]
        else
            return [:Str]

    convert s:Str as Glob
        return bitcast ([
            for c in s
                if c is `\;`{;`};`*;`?;`[;`]
                    ++[`\, c]
                is plain
                    ++[plain]
        ]) as Glob

if IS_MAIN_PROGRAM
    >>> Glob::"*.c".expand()
    >>> filename := "*"
    >>> Glob::"$filename".expand()
