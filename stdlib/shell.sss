// Defines a DSL for shell commands and a way to run them safely

def _POpenFile{}

extend $Sh
    def run(sh:$Sh)->{output:Str,status:Int32}
        popen := (extern popen:(command:@CStringChar, type:@CStringChar)->?_POpenFile)
        f := popen(bitcast sh as Str, "r") or return {output="", status=-1i32}
        output := (extern sss_readfile:(f:&@_POpenFile,bytes=Int64.max)->Str)(&f)
        pclose := (extern pclose:(?_POpenFile)->Int32)
        status := pclose(f)
        if status >= 0
            status = (status / 256i32) and 0xFFi32
        return {output=output, status=status}

    def run_with(sh:$Sh , input:Str)->Int32
        popen := (extern popen:(command:@CStringChar, type:@CStringChar)->?_POpenFile)
        f := popen("$sh", "w") or return -1i32
        pclose := (extern pclose:(?_POpenFile)->Void)
        fwrite := (extern fwrite:(text:@CStringChar,element_size=1,len:Int64,f:@_POpenFile,bytes=Int64.max)->Void)
        fwrite(input,1,#input,f)
        pclose := (extern pclose:(?_POpenFile)->Int32)
        status := pclose(f)
        if status >= 0
            status = (status / 256i32) and 0xFFi32
        return status

def s:Str as $Sh
    return bitcast "'$(s.replace("'",${'"'"'}))'" as $Sh

def strs:[Str] as $Sh
    return bitcast [
        for s in strs
            ++$Sh"$s"
        between
            ++$Sh" "
    ] as $Sh

def strings:[Str] as $Sh
    return bitcast [
        for s in strings
            c for c in $Sh"$s"
        between
            ` 
    ] as $Sh

def i:Int64 as $Sh
    return bitcast "$i" as $Sh

def n:Num as $Sh
    return bitcast "$n" as $Sh

if IS_MAIN_PROGRAM
    >>> files := ["one two", "three; four", "doesn't break"]
    >>> $Sh> ls -al @files
    === $Sh"ls -al 'one two' 'three; four' 'doesn'\"'\"'t break'"
    >>> $Sh(echo "hi").run()
    === {output="hi\n", status=0_i32}
