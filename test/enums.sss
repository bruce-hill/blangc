enum Foo := A | B | C | D

say "$(Foo.A)"
fail unless "$(Foo.A)" == "Foo.A"

for x in [Foo.A, Foo.B, Foo.C, Foo.D]
    if x matches A
        say "$x matches A!"
    matches B
        say "$x matches B!"
    else
        say "$x matches something else"

enum Baz := Text(text:Str)
    | Integer(i:Int)
    | Vec2(x:Num, y:Num)
    | Nil

bazzes := [Baz.Text("hi"), Baz.Integer(5), Baz.Vec2(2.4, 4), Baz.Nil]

for b in bazzes
    if b matches Text(t)
        say "$t"
    matches Integer(x); Vec2(x)
        say "$x"
    matches Nil
        say "nil"

// Flags:
enum Flags := None=0 | A=1 | B=2 | C=4 | D=8
>>> abc := Flags.A + Flags.B + Flags.C
>>> abc
=== Flags.A+B+C
>>> abc + Flags.A
=== Flags.A+B+C
>>> Flags.B in abc
=== yes
>>> Flags.D in abc
=== no
>>> abc - Flags.B
=== Flags.A+C
>>> not (Flags.A or Flags.B)
=== Flags.C+D
>>> (Flags.A+Flags.B) xor Flags.B
=== Flags.A

// Test for accessing type scopes:
func doop(b:Baz)->Baz
    return Nil
>>> doop(Text("hi"))
=== Baz.Nil
struct HasBaz{x:Int, b:Baz}
>>> HasBaz{Integer(3), x=9}
=== HasBaz{x=9, b=Baz.Integer(i=3)}
