a := 3_000 // Underscores can separate chunks
b := 2
x := 3.5
// y := 2e3 // Scientific notation
y := 2_000
say "Literals: $(123) $(123_456) $(-123) $(0xFF) $(-0xFF) $(0o777) $(-0o777) $(0b111) $(-0b111)"
say "Addition: $a+$b=$(a+b) $x+$y=$(x+y)"
say "Subtraction: $a-$b=$(a-b) $x-$y=$(x-y)"
say "Multiplication: $a*$b=$(a*b) $x*$y=$(x*y)"
say "Division: $a/$b=$(a/b) $x/$y=$(x/y)"
say "Modulus: $a mod $b=$(a mod b) $x mod 1=$(x mod 1.)"
say "Negative num modulus: -$a mod $b=$(-a mod b) -$x mod 1=$(-x mod 1.)"
say "Negative modulus: $a mod -$b=$(a mod -b) $x mod -1=$(x mod -1.)"
// say "Exponentiation: $a^$b=$(a^b) $x^2.5=$(x^2.5)"

long := 1 + 2 - 3 - 4 + 5 - 6 * 7 * 8 / 2
fail unless long == -167
say "Long chain: $long"

f := 23.5
say "$f casts to int: $(cast f:Int)"
fail unless cast f:Int == 23
say "$f reinterpreted as int: $(bitcast f:Int)"

i := 123
say "$i casts to float: $(cast i:Num)"
fail unless cast i:Num == 123.0
say "$i reinterpreted as float: $(bitcast i:Num)"

fail unless cast 23.5:Int8 == 23i8
fail "23 as Num32 = $(cast 23:Num32)" unless cast 23:Num32 == 23.0f32

def fast_inverse_sqrt(number:Num):Num
    x2 := number * 0.5
    y := number
    i := bitcast number:Int
    i = 0x5FE6EB50C7B537A9 - (i / 2) // what the fuck? 
    y = bitcast i:Num
    y *= (1.5 - (x2 * y * y)) // 1st iteration
    y *= (1.5 - (x2 * y * y)) // 2nd iteration, this can be removed
    y *= (1.5 - (x2 * y * y)) // 3rd iteration, this can be removed
    return y

test := 16.
say "fast_inverse_sqrt($test) = $(fast_inverse_sqrt test)"
result := fast_inverse_sqrt(16.)
fail "got $result instead of 0.25" unless "$result" == "0.25"
