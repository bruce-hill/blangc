extern hypot:(Num,Num)->Num
def Vec {x,y:Num}
    def len(v:Vec):Num
        return hypot(v.x, v.y)

    def dot(v:Vec, other:Vec):Num return v.x*other.x + v.y*other.y
    def as_string(v:Vec):String return "Vec<$(v.x),$(v.y)>"

v := Vec{2.3, 4.5}
say "$:v"
say "$:(v.x)"
say "$:(v.dot(v))"

// Math ops
say "$:v; $:(v+v) $:(v-v) $:(v*v) $:(v/v)"
say "$:v; $:(v+100) $:(100+v) $:(v-100) $:(100-v) $:(100*v) $:(v*100) $:(100/v) $:(v/100)"

say "$:(Vec{1.,1.} == Vec{1.,1.})"

def Nested {
    n:Int
    v1,v2:Vec
}

n := Nested{10, Vec{1,2},Vec{3,4}}
say "$n"
say "$:(n+n) $:(100*n)"


// Recursive struct
def Tree {
    value:Int
    left,right:?@Tree
}

t := @Tree{5, left=@Tree{0}}
// t.right = t
// say "Recursive struct with cyclical references: $t"


// Inline structs
// do
//     struct Inline {
//         first:String
//         ..vec:Vec
//         last:String
//     }

//     inline := Inline{"hello", Vec{1.,2.}, "bye"}
//     say "Inline struct: $inline"
//     fail unless "$inline" == "Inline{first=hello, vec=Vec<1,2>, last=bye}"

//     vec := inline.vec
//     say "Extracted inline member: $vec"
//     fail unless "$vec" == "Vec<1,2>"

//     inline.vec = Vec{100.,200.}
//     say "Updated inline member: $vec"
//     fail unless "$inline" == "Inline{first=hello, vec=Vec<100,200>, last=bye}"

//     inline = Inline{"xxx", Vec{0.,0.}, "xxx"}
//     extern GC_gcollect():NilType
//     GC_gcollect()
//     say "Extracted inline member persists and keeps updates: $vec"
//     fail unless "$vec" == "Vec<100,200>"
