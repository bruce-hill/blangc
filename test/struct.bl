extern hypot:(Num,Num)->Num
def Vec {x,y:Num}
    def len(v:Vec):Num
        return hypot(v.x, v.y)

    def dot(v:Vec, other:Vec):Num return v.x*other.x + v.y*other.y
    def as_string(v:Vec):String return "Vec<$(v.x),$(v.y)>"

v := Vec{2.3, 4.5}
say "$:v"
say "$:(v.x)"
say "$:(v.dot(v))"

// Math ops
say "$:v; $:(v+v) $:(v-v) $:(v*v) $:(v/v)"
say "$:v; $:(v+100) $:(100+v) $:(v-100) $:(100-v) $:(100*v) $:(v*100) $:(100/v) $:(v/100)"

say "$:(Vec{1.,1.} == Vec{1.,1.})"

def Nested {
    n:Int
    v1,v2:Vec
}

n := Nested{10, Vec{1,2},Vec{3,4}}
say "$n"
say "$:(n+n) $:(100*n)"


// Recursive struct
say "Recursive struct test:"
def Tree {
    value:Int
    left,right:?@Tree
}

>>> l := @Tree{6}
>>> t := @Tree{5, left=l}
>>> t.right = t
>>> l.left = l
>>> t
=== @Tree{value=5, left=@Tree{value=6, left=@Tree#2, right=!Tree}, right=@Tree#1}
