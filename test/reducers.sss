// Reducers take the form: |reduction| iteralbe else fallback
// `reduction` can be either an expression using `x` and `y` or an infix operator
// If `else fallback` is omitted, the fallback will default to runtime failure

>>> nums := [2,-3,4]

// 'x' and 'y' are implicit variables for the reduction:
>>> |x+y| nums
=== 3

// Infix operators can be used directly:
>>> |+| nums
=== 3

>>> |_max_| nums
=== 4
>>> |_min_| nums
=== -3

>>> |*| nums
=== -24

>>> |x.abs()+y.abs()| nums
=== 9

>>> |+| n.abs() for n in nums
=== 9

>>> |(if x.abs() < y.abs() then x else y)| nums
=== 2

>>> |_min_.abs()| nums
=== 2

>>> |+| nums else 100
=== 3

>>> |+| [:Int] else 100
=== 100

>>> |x++" "++y| ["one","two","three"] else ""
=== "one two three"

struct Vec{x,y:Num}
>>> vecs := [Vec{1,2}, Vec{1,3}, Vec{2,1}, Vec{3,1}]
>>> |_max_| vecs
>>> Vec{x=3, y=1}
>>> |_max_.y| vecs
>>> Vec{x=1, y=3}
