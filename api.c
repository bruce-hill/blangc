// Logic for generating a .sss.api file from a .sss file:

#include <fcntl.h>
#include <stdio.h>
#include <stdint.h>

#include "api.h"
#include "util.h"
#include "libsss/list.h"

static const char *get_unique_id()
{
    int fd = open("/dev/urandom", O_RDONLY);
    uint64_t num = 0;
    read(fd, &num, sizeof(num));
    close(fd);
    return heap_strf("%0X", num);
}

static void write_to_api_file(FILE *f, const char *prefix, ast_t *ast)
{
    switch (ast->tag) {
        case Block: {
            LIST_FOR (Match(ast, Block)->statements, stmt, _)
                write_to_api_file(f, prefix, *stmt);
            break;
        }
        case Use: {
            fprintf(f, "%s*; %s; use %s\n", prefix, get_unique_id(), Match(ast, Use)->path);
            break;
        }
        case Declare: {
            auto decl = Match(ast, Declare);
            if (decl->value->tag == Use)
                fprintf(f, "%s%#W; %s; use %s\n", prefix, decl->var, get_unique_id(), Match(decl->value, Use)->path);
            else
                write_to_api_file(f, prefix, decl->value);
            break;
        }
        case StructDef: {
            auto def = Match(ast, StructDef);
            if (def->name[0] == '_') break;
            fprintf(f, "%s%s; %s; struct{", prefix, def->name, get_unique_id());
            auto fields = def->fields;
            for (int64_t i = 0; i < LIST_LEN(fields.types); i++) {
                const char *name = LIST_ITEM(fields.names, i);
                ast_t *type = LIST_ITEM(fields.types, i);
                ast_t *val = LIST_ITEM(fields.defaults, i);
                if (i > 0) fprintf(f, ", ");
                fprintf(f, "%s", name);
                if (type) fprintf(f, ":%#W", type);
                if (val) fprintf(f, "=%#W", val);
            }
            fprintf(f, "}\n");
            LIST_FOR(def->definitions, child, _)
                write_to_api_file(f, heap_strf("%s%s.", prefix, def->name), *child);
            break;
        }
        case TaggedUnionDef: {
            auto def = Match(ast, TaggedUnionDef);
            if (def->name[0] == '_') break;
            fprintf(f, "%s%s; %s; enum(", prefix, def->name, get_unique_id());
            for (int64_t i = 0; i < LIST_LEN(def->tag_names); i++) {
                if (i > 0) fprintf(f, " | ");
                const char *tag_name = LIST_ITEM(def->tag_names, i);
                auto tag_args = LIST_ITEM(def->tag_args, i);
                fprintf(f, "%s(", tag_name);
                for (int64_t j = 0; j < LIST_LEN(tag_args.types); j++) {
                    if (j > 0) fprintf(f, ", ");
                    const char *arg_name = LIST_ITEM(tag_args.names, j);
                    ast_t *arg_type = LIST_ITEM(tag_args.types, j);
                    fprintf(f, "%s:%#W", arg_name, arg_type);
                }
                int64_t tag_val = LIST_ITEM(def->tag_values, i);
                fprintf(f, ")=%ld", tag_val);
            }
            fprintf(f, ")\n");

            LIST_FOR(def->definitions, child, _)
                write_to_api_file(f, heap_strf("%s%s.", prefix, def->name), *child);

            break;
        }
        case ConvertDef: {
            auto def = Match(ast, ConvertDef);
            fprintf(f, "%sconvert; %s; %#W as %#W\n", prefix, get_unique_id(), def->source_type, def->target_type);
            break;
        }
        case VariantDef: {
            auto def = Match(ast, VariantDef);
            if (def->name[0] == '_') break;
            fprintf(f, "%s%s; %s; alias(%#W)\n", prefix, def->name, get_unique_id(), def->variant_of);
            write_to_api_file(f, heap_strf("%s%s.", prefix, def->name), def->body);
            break;
        }
        case FunctionDef: {
            auto def = Match(ast, FunctionDef);
            if (def->name[0] == '_') break;
            fprintf(f, "%s%s; %s; func(", prefix, def->name, get_unique_id());
            for (int64_t i = 0; i < LIST_LEN(def->args.types); i++) {
                const char *name = LIST_ITEM(def->args.names, i);
                ast_t *type = LIST_ITEM(def->args.types, i);
                ast_t *val = LIST_ITEM(def->args.defaults, i);
                if (i > 0) fprintf(f, ", ");
                fprintf(f, "%s", name);
                if (type) fprintf(f, ":%#W", type);
                if (val) fprintf(f, "=%#W", val);
            }
            if (def->ret_type)
                fprintf(f, ")->%#W\n", def->ret_type);
            else
                fprintf(f, ")->Void\n");
            break;
        }
        default: break;
    }
}

void generate_api_file(const char *sss_filename, ast_t *ast)
{
    FILE *f = fopen(heap_strf("%s.api", sss_filename), "w");
    fprintf(f, "// Autogenerated %s.api file, DO NOT EDIT\n", sss_filename);
    fprintf(f, "#load; %s; func()->Void\n", get_unique_id());
    write_to_api_file(f, "", ast);
    fclose(f);

    // Echo to stdout:
    f = fopen(heap_strf("%s.api", sss_filename), "r");
    char buf[1024];
    for (size_t chunk; (chunk = fread(buf, 1, sizeof(buf), f)) > 0; ) {
        fwrite(buf, 1, chunk, stdout);
    }
    fclose(f);
}
